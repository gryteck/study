# Парадигмы программирования
Парадигма программирования определяют стандарты написания кода. <br>
Разделяют:
- `императивная` парадигма (ООП и процедурное)
- `декларативная` парадигма (функциональное и логическое)

Императивное программирование заключается в последовательном выполнении действий.
Декларативная парадигма заключается в 

<details> <summary>Объектно-ориентированное программирование [ Инкапсуляция, наследование, полиморфизм ]</summary>

`Объектно-ориентированное программирование` (ООП) - это парадигма программирования, которая основана на концепциях объектов и классов. <br>

Все данные и функции объединяются в объекты, которые являются экземплярами классов.<br>

Классы определяют структуру объектов, их поведения и свойства.<br>

Различают четыре принципа ООП: `инкапсуляция`, `наследование`, `полиморфизм` и `абстракция`<br>
____
`Инкапсуляция` - механизм языка, позволяющий объединять данные и методы, работающие с этими данными в единый объект и скрыть детали реализации от пользователя. <br> 

Подлинное назначение - собрать в одном месте знания, относящиеся к устройству некой сущности, правилам обращения и операциям с ней.
Противоположность инкапсуляции - размывание знаний о функционировании.<br>
<details><summary> Пример инкапсуляции: </summary>

```
class Human:
    name: str
    age: int

    def __init__(self, name, age):
        self.name = name
        self.age = age

    # public
    def live(self):
        self.__walk()
        self.__speak()

    # private
    def __walk(self):
        return print(f"I'm {self.age} y.o. and I can walk...")

    def __speak(self):
        return print(f"Hi, my name is {self.name}")

    # protected
    def _run(self):
        return print(f"I'm {self.age} y.o. and I'm running...")


Alibek = Human('Alibek', 23)
Alibek.live()
Alibek._run()  # warning from IDE - Access to a protected member!
Alibek._Human__walk()  # warning from IDE - Unresolved attribute reference!
```
</details>

`Наследование` - механизм языка, который позволяет описывать новый класс на основе существующего. <br>
В "истинном" ООП нужен для реализации полиморфизма.<br>

<details><summary> Пример наследования: </summary>

```
class Animal:
    __name: int

    def __init__(self, name):
        self.__name = name

    def speak(self):
        pass


class Cat(Animal):
    def speak(self):
        return print("Meoww")


class Dog(Animal):
    def speak(self):
        return print("Woof")


Vasya = Cat('Vasya')
Aktos = Dog('Aktos')
Cheburawka = Animal('Cheburawka')

for i in (Vasya, Aktos, Cheburawka):
    i.speak()

```
</details>

`Полиморфизм` - возможность схожим типам данных, которые явно заданы иерархией наследования иметь различные реализации (с помощью переопределения методов и апкаста)<br>
Также иногда под полиморфизмом имеется ввиду способность обрабатывать разные типы данных.<br> 

`Абстракция` гласит, что мы должны выделять главные характеристики объекта. 
Мысль в том, чтобы мы могли определить минимальный необходимый набор этих характеристик, чтобы решать поставленные задачи. 
Достаточно тривиальная парадигма, почему ее часто не учитывают в принципах ООП.

</details>

<details> <summary> Принципы программирования [ DRY, SOLID, KISS, SLAP ]</summary>

`KISS` (Keep it stupid simple) велит придерживаться простоты. Имеется ввиду отказ от хитроумных приемов и утяжеления.
Чем проще ваш код тем легче его читать вам и тем кто будет его поддерживать <br>

`DRY` (Don't repeat yourself) - велит нам каждое повторение кода обособлять. 
Если в коде есть два и более повторяющихся фрагмента кода это в дальнейшем может привести к рассинхронизации и багам.<br>

`YAGNI` (You ain't gonna need it) - заключается в том что не нужно оставлять лишние фрагменты кода только для облегченного расширения функционала в будущем.
Такие ситуации вносят ненужную сложность и увеличивают размер кода

`SOLID` аббревиатура от 5 принципов которые характерны ООП:<br>
S: Single responsibility (единственной ответственности)<br>
O: Open-closed (открытости-закрытости) <br> 
L: Liskov Substitution (Подстановки Барбары Лисков) <br>
I: Interface segregation (Принцип разделения интерфейсов)<br>
D: Dependency Inversion ()<br>
</details>
